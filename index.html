<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Calculadora Método Simplex con Dos Fases</title>
  <style>
    body { font-family: Arial, sans-serif; padding: 20px; max-width: 600px; margin: auto; }
    input, textarea { width: 100%; margin-bottom: 10px; padding: 8px; font-size: 16px; }
    button { padding: 10px 20px; font-size: 16px; cursor: pointer; }
    pre { background: #f0f0f0; padding: 15px; white-space: pre-wrap; }
  </style>
</head>
<body>

  <h2>Calculadora Método Simplex (Método de Dos Fases)</h2>

  <label>Función Objetivo (ej: 3x + 5y):</label>
  <input type="text" id="objetivo" value="3x + 5y" />

  <label>Restricciones (una por línea, ej: x + 2y <= 6):</label>
  <textarea id="restricciones" rows="6">x + 2y <= 6
3x + 2y >= 12
x + y = 7</textarea>

  <button onclick="resolverSimplex()">Resolver</button>

  <h3>Resultado:</h3>
  <pre id="resultado"></pre>

<script>
  // --- Parseo de entrada para variables, restricciones y coeficientes ---
  function parseInput(objetivoStr, restriccionesStr) {
    let variables = [];

    // Extraer variables de función objetivo
    objetivoStr.replace(/([+-]?\s*\d*)\s*([a-z])/gi, (_, coef, v) => {
      if (!variables.includes(v)) variables.push(v);
    });

    // Extraer coeficientes función objetivo
    const objetivo = variables.map(v => {
      const match = objetivoStr.match(new RegExp("([+-]?\\s*\\d*)\\s*" + v, "i"));
      if (match) {
        return parseFloat(match[1].replace(/\s/g, '') || (match[1].includes('-') ? -1 : 1));
      }
      return 0;
    });

    // Procesar restricciones
    const restricciones = [];
    restriccionesStr.trim().split('\n').forEach(line => {
      const match = line.match(/(.+)\s*(<=|=|>=)\s*(\d+(\.\d+)?)/);
      if (!match) return;
      let [_, lhs, signo, rhs] = match;
      rhs = parseFloat(rhs);
      // Extraer coeficientes por variable
      const coef = variables.map(v => {
        const coefMatch = lhs.match(new RegExp("([+-]?\\s*\\d*\\.?\\d*)\\s*" + v, "i"));
        if (coefMatch) {
          let val = coefMatch[1].replace(/\s/g, '');
          if (val === '' || val === '+') val = '1';
          else if (val === '-') val = '-1';
          return parseFloat(val);
        }
        return 0;
      });
      restricciones.push({ coef, signo, rhs });
    });

    return { objetivo, restricciones, variables };
  }

  // --- Construir tabla simplex con holgura, excedente y artificiales ---
  function construirTabla(objetivo, restricciones) {
    let tabla = [];
    let artiCols = [];
    let numRes = restricciones.length;
    let numVars = objetivo.length;

    // Contar variables artificiales y posición para agregarlas
    let colsExtra = 0;

    // Crear matriz base (coeficientes, holguras, excedentes, artificiales, RHS)
    // Para cada restricción agregamos según el tipo:
    // <=: agregar variable holgura
    // >=: agregar variable excedente (-1) + artificial
    // =: agregar artificial

    // Contadores para columnas extra
    let holguras = 0;
    let artificiales = 0;

    restricciones.forEach(r => {
      if (r.signo === "<=") holguras++;
      else if (r.signo === ">=") {
        holguras++; // para excedente contamos como variable extra también
        artificiales++;
      } else if (r.signo === "=") {
        artificiales++;
      }
    });

    colsExtra = holguras + artificiales;

    // Crear tabla fila por fila
    restricciones.forEach((r, i) => {
      let fila = [...r.coef];

      // Añadir variables holgura, excedente, artificial
      // Primero holgura (1 para <=), excedente (-1 para >=), artificial (1 para >= o =)
      let h = 0, a = 0;
      // Agregar ceros para las extras
      for (let j=0; j<colsExtra; j++) fila.push(0);

      let idxExtra = numVars; // columnas extras empiezan tras variables originales
      for (let k=0; k<i; k++) {
        if (restricciones[k].signo === "<=") idxExtra++;
        else if (restricciones[k].signo === ">=") idxExtra += 2;
        else if (restricciones[k].signo === "=") idxExtra++;
      }

      if (r.signo === "<=") {
        fila[idxExtra] = 1; // variable holgura
      } else if (r.signo === ">=") {
        fila[idxExtra] = -1; // variable excedente
        fila[idxExtra + 1] = 1; // variable artificial
        artiCols.push(idxExtra + 1);
      } else if (r.signo === "=") {
        fila[idxExtra] = 1; // variable artificial
        artiCols.push(idxExtra);
      }

      // RHS
      fila.push(r.rhs);

      tabla.push(fila);
    });

    // Fila Z para Fase 1: minimizar suma variables artificiales (coef -1 en artiCols)
    const totalCols = numVars + colsExtra + 1;
    let filaZ1 = Array(totalCols).fill(0);
    artiCols.forEach(c => filaZ1[c] = -1);
    tabla.push(filaZ1);

    return { tabla, artiCols };
  }

  // --- Iteración simplex (una sola iteración) ---
  function simplexIteracion(tabla) {
    const numFilas = tabla.length;
    const numCols = tabla[0].length;

    const filaZ = tabla[numFilas - 1];
    const costos = filaZ.slice(0, numCols - 1);
    const minCosto = Math.min(...costos);
    if (minCosto >= -1e-10) return false; // óptimo

    const colPivote = costos.indexOf(minCosto);

    let minRatio = Infinity;
    let filaPivote = -1;
    for (let i = 0; i < numFilas - 1; i++) {
      const elemento = tabla[i][colPivote];
      if (elemento > 1e-10) {
        const ratio = tabla[i][numCols - 1] / elemento;
        if (ratio < minRatio) {
          minRatio = ratio;
          filaPivote = i;
        }
      }
    }
    if (filaPivote === -1) throw new Error("Problema no acotado");

    // Normalizar fila pivote
    const pivote = tabla[filaPivote][colPivote];
    for (let j = 0; j < numCols; j++) {
      tabla[filaPivote][j] /= pivote;
    }

    // Reducir otras filas
    for (let i = 0; i < numFilas; i++) {
      if (i !== filaPivote) {
        const factor = tabla[i][colPivote];
        for (let j = 0; j < numCols; j++) {
          tabla[i][j] -= factor * tabla[filaPivote][j];
        }
      }
    }
    return true;
  }

  // --- Fase 1: minimizar suma variables artificiales ---
  function faseUno(tabla, artiCols) {
    let iter = 0;
    while (simplexIteracion(tabla)) {
      iter++;
      if (iter > 100) throw new Error("Demasiadas iteraciones en fase 1");
    }
    const z = tabla[tabla.length - 1][tabla[0].length - 1];
    if (Math.abs(z) > 1e-8) {
      throw new Error("No hay solución factible (fase 1)");
    }
    // Quitar columnas artificiales
    artiCols.sort((a, b) => b - a);
    for (let c of artiCols) {
      tabla.forEach(fila => fila.splice(c, 1));
    }
  }

  // --- Preparar tabla para Fase 2: función objetivo original ---
  function prepararFaseDos(tabla, objetivo) {
    const numCols = tabla[0].length;
    const filaZ = Array(numCols).fill(0);
    for(let i=0; i<objetivo.length; i++){
      filaZ[i] = -objetivo[i];
    }
    filaZ[numCols-1] = 0;
    tabla[tabla.length -1] = filaZ;

    // Ajustar fila Z para variables básicas existentes
    for(let i=0; i<tabla.length-1; i++){
      const fila = tabla[i];
      const coefBase = filaZ.slice(0, numCols -1);
      for(let j=0; j < numCols-1; j++){
        if(Math.abs(fila[j] - 1) < 1e-10){
          // Restar fila i multiplicada por coefBase[j] a fila Z
          for(let k=0; k < numCols; k++){
            tabla[tabla.length -1][k] -= coefBase[j] * fila[k];
          }
        }
      }
    }
  }

  // --- Fase 2: resolver función objetivo original ---
  function faseDos(tabla) {
    let iter = 0;
    while (simplexIteracion(tabla)) {
      iter++;
      if (iter > 100) throw new Error("Demasiadas iteraciones en fase 2");
    }
  }

  // --- Función principal para resolver ---
  function resolverSimplex() {
    try {
      const objetivoStr = document.getElementById("objetivo").value;
      const restriccionesStr = document.getElementById("restricciones").value;
      const { objetivo, restricciones, variables } = parseInput(objetivoStr, restriccionesStr);

      const { tabla, artiCols } = construirTabla(objetivo, restricciones);

      faseUno(tabla, artiCols);

      prepararFaseDos(tabla, objetivo);

      faseDos(tabla);

      // Obtener solución
      let solucion = Array(variables.length).fill(0);
      for (let i = 0; i < variables.length; i++) {
        let col = tabla.map(row => row[i]);
        // Buscar columna básica (un solo 1, resto 0 en restricciones)
        let unos = col.filter((v, idx) => idx < tabla.length -1 && (Math.abs(v - 1) < 1e-10)).length;
        let ceros = col.filter((v, idx) => idx < tabla.length -1 && (Math.abs(v) < 1e-10)).length;
        if (unos === 1 && ceros === tabla.length -2) {
          let fila = col.findIndex((v, idx) => idx < tabla.length -1 && (Math.abs(v - 1) < 1e-10));
          solucion[i] = tabla[fila][tabla[0].length -1];
        }
      }

      const z = tabla[tabla.length -1][tabla[0].length -1];

      document.getElementById("resultado").textContent =
        `Z = ${z.toFixed(4)}\n` +
        variables.map((v, i) => `${v} = ${solucion[i].toFixed(4)}`).join('\n');

    } catch (e) {
      document.getElementById("resultado").textContent = "Error: " + e.message;
    }
  }
</script>

</body>
</html>
